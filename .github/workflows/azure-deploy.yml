name: Build, Test & Deploy to Azure Container Apps

on:
  pull_request:
    branches: ["*"]
  push:
    branches: ["main"]

env:
  COMPOSE_FILE: docker-compose.yml

jobs:
  build-test:
    name: Build & Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout source
        uses: actions/checkout@v4

      - name: Setup .NET 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Restore dependencies
        run: dotnet restore

      - name: Build
        run: dotnet build --no-restore --configuration Release

      - name: Run tests
        run: dotnet test tests/fcg.GameService.UnitTests/fcg.GameService.UnitTests.csproj --no-build --configuration Release --verbosity normal

      - name: Validate docker-compose build
        run: docker compose -f ${{ env.COMPOSE_FILE }} build

  deploy:
    name: Deploy to Azure Container Apps
    runs-on: ubuntu-latest
    needs: build-test
    if: github.ref == 'refs/heads/main'

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      # Login to Azure
      - name: Azure login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      # Ensure RG, ACR, and ACA environment exist
      - name: Ensure Azure Resources
        run: |
          az group create -n ${{ vars.RESOURCE_GROUP }} -l ${{ vars.LOCATION }}

          az acr show -n ${{ vars.ACR_NAME }} -g ${{ vars.RESOURCE_GROUP }} \
          || az acr create -n ${{ vars.ACR_NAME }} -g ${{ vars.RESOURCE_GROUP }} --sku ${{ vars.ACR_SKU }}

          az containerapp env show -n ${{ vars.ACA_ENV }} -g ${{ vars.RESOURCE_GROUP }} \
          || az containerapp env create -n ${{ vars.ACA_ENV }} -g ${{ vars.RESOURCE_GROUP }} -l ${{ vars.LOCATION }}

      - name: ACR Login
        run: az acr login --name ${{ vars.ACR_NAME }}

      - name: Build and Push images
        run: |
          # Generate unique version tag based on commit SHA and timestamp
          VERSION=$(echo ${{ github.sha }} | cut -c1-7)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          FULL_VERSION="${VERSION}-${TIMESTAMP}"
          
          echo "Building images with version: $FULL_VERSION"
          
          # Build local images
          docker compose -f ${{ env.COMPOSE_FILE }} build

          # Tag and push each service image to ACR with both latest and versioned tags
          SERVICES=$(docker compose -f ${{ env.COMPOSE_FILE }} config --services | xargs)
          for service in $SERVICES; do
            LOCAL_IMAGE=$(docker compose -f ${{ env.COMPOSE_FILE }} config | awk "/image:/ && /$service/ {print \$2}")
            
            # Tag with versioned tag
            ACR_VERSIONED_IMAGE="${{ vars.REGISTRY }}/$service:$FULL_VERSION"
            docker tag $LOCAL_IMAGE $ACR_VERSIONED_IMAGE
            docker push $ACR_VERSIONED_IMAGE
            
            # Tag with latest tag
            ACR_LATEST_IMAGE="${{ vars.REGISTRY }}/$service:latest"
            docker tag $LOCAL_IMAGE $ACR_LATEST_IMAGE
            docker push $ACR_LATEST_IMAGE
            
            echo "Pushed $service: $ACR_VERSIONED_IMAGE and $ACR_LATEST_IMAGE"
          done
          
          # Export version for use in deployment step
          echo "IMAGE_VERSION=$FULL_VERSION" >> $GITHUB_ENV

      - name: Deploy services with ingress, secrets, and probes
        run: |
          # Common env vars (shared across apps)
          ENV_VARS=(
            "ASPNETCORE_ENVIRONMENT=Production"
            "MongoDbSettings__ConnectionString=${{ secrets.MONGO_CONNECTION}}"
            "MongoDbSettings__DatabaseName=${{secrets.MONGO_DATABASE}}"
            "ElasticSettings__ApiKey=${{secrets.ELASTIC_APIKEY}}"
            "ElasticSettings__CloudId=${{secrets.ELASTIC_CLOUDID}}"
            "AzureStorage__ConnectionString=${{secrets.QUEUE_CONNECTION}}"
            "AzureStorage__ProducerQueueName=${{secrets.QUEUE_PRODUCER_NAME}}"
            "AzureStorage__ConsumerQueueName=${{secrets.QUEUE_CONSUMER_NAME}}"
            "OTEL_RESOURCE_ATTRIBUTES=${{secrets.OTEL_RESOURCE_ATTRIBUTES}}"
            "OTEL_EXPORTER_OTLP_ENDPOINT=${{secrets.OTEL_EXPORTER_OTLP_ENDPOINT}}"
            "OTEL_EXPORTER_OTLP_HEADERS=${{secrets.OTEL_EXPORTER_OTLP_HEADERS}}"
            "OTEL_EXPORTER_OTLP_PROTOCOL=${{secrets.OTEL_EXPORTER_OTLP_PROTOCOL}}"
          )

          # Get services from docker-compose
          SERVICES=$(docker compose -f ${{ env.COMPOSE_FILE }} config --services | xargs)

          for service in $SERVICES; do
            # Use versioned image to ensure new revision creation
            IMAGE=${{ vars.REGISTRY }}/$service:${{ env.IMAGE_VERSION }}
            echo "Deploying $service -> $IMAGE (version: ${{ env.IMAGE_VERSION }})"

            # Check if container app exists
            if az containerapp show --name $service --resource-group ${{ vars.RESOURCE_GROUP }} > /dev/null 2>&1; then
              echo "Container app $service exists, updating to create new revision..."
              az containerapp update \
                --name $service \
                --resource-group ${{ vars.RESOURCE_GROUP }} \
                --image $IMAGE \
                --min-replicas 1 \
                --max-replicas 3 \
                --registry-server ${{ vars.REGISTRY }} \
                --registry-username $(az acr credential show -n ${{ vars.ACR_NAME }} --query "username" -o tsv) \
                --registry-password $(az acr credential show -n ${{ vars.ACR_NAME }} --query "passwords[0].value" -o tsv) \
                --set-env-vars ${ENV_VARS[@]}
              
              echo "Successfully updated $service with new revision using image: $IMAGE"
            else
              echo "Container app $service does not exist, creating new app..."
              az containerapp create \
                --name $service \
                --resource-group ${{ vars.RESOURCE_GROUP }} \
                --environment ${{ vars.ACA_ENV }} \
                --image $IMAGE \
                --target-port 8080 \
                --ingress external \
                --transport auto \
                --min-replicas 1 \
                --max-replicas 3 \
                --registry-server ${{ vars.REGISTRY }} \
                --registry-username $(az acr credential show -n ${{ vars.ACR_NAME }} --query "username" -o tsv) \
                --registry-password $(az acr credential show -n ${{ vars.ACR_NAME }} --query "passwords[0].value" -o tsv) \
                --env-vars ${ENV_VARS[@]}
              
              echo "Successfully created $service with image: $IMAGE"
            fi
          done
